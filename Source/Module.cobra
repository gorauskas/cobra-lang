use System.Reflection

class Module  # CC: mark abstract
	inherits Node

	# TODO: Seems that much of Module's guts should be moved down to CobraModule

	var _fileName as String
	var _csFileName = ''
	var _docString as String?

	def init(fileName as String, verbosity as int, docString as String)
		require fileName
		base.init
		_fileName = fileName
		_docString = docString
		# TODO: what's going on with verbosity?

	get docString from var

	get fileName from var

	get csFileName from var

	get isCobraLibrary as bool
		return _fileName.endsWith('CobraLang.cobra') or _fileName.endsWith('CobraLang.cs') or _fileName.endsWith('SystemInterfaces.cobra')

	get csSource as String
		if _csFileName.length
			return File.readAllText(_csFileName)
		else
			throw FallThroughException('csFileName is blank')

	def addMinFields
		base.addMinFields
		.addField('fileName', _fileName)

	def bindUse
		pass

	def writeSharpDef as Dictionary<of int, int>
		# CC: mark abstract
		return nil to passthrough

	def writeSharpTestInvocation(sw as SharpWriter)
		pass


class SharpModule
	inherits Module
	"""
	The purpose of a C# module is to allow the programmer to include .cs command for Cobra to
	incorporate in the final compilation.
	"""

	def init(fileName as String, verbosity as int)
		base.init(fileName, verbosity, '')
		_csFileName = fileName

	def writeSharpDef as Dictionary<of int, int> is override
		# kind of silly, but it works:
		d = Dictionary<of int, int>()
		for i = 1 .. Utils.countChars(File.readAllText(_csFileName), c'\n')+1
			d[i] = i
		return d


class AssemblyModule
	inherits Module
	"""
	An assembly module represents a .dll
	"""
	
	var _topNameSpace as NameSpace

	def init(ass as Assembly, globalNS as NameSpace)
		.init(ass, 0, globalNS)

	def init(ass as Assembly, verbosity as int, globalNS as NameSpace)
		base.init(ass.location, verbosity, '')
		_topNameSpace = NameSpace(globalNS, '(top namespace for assembly [ass])')
		_csFileName = ''

	get topNameSpace from var
		"""
		Returns the top namespace for this module.
		This is an implicit namespace that is not unified (its unified namespace is the global namespace).
		"""

	def bindUse
		base.bindUse
		.topNameSpace.bindUse

	def _bindInt
		base._bindInt
		# .topNameSpace.bindInt - It's too expensive to scan all types in a DLL. Do them as needed.

	def writeSharpDef as Dictionary<of int, int> is override
		return Dictionary<of int, int>()	


class CobraModule
	inherits Module

	var _topNameSpace as NameSpace
	
	def init(fileName as String, verbosity as int, docString as String, globalNS as NameSpace)
		base.init(fileName, verbosity, docString)
		_topNameSpace = NameSpace(globalNS, '(top namespace for module [fileName])')
		if not _fileName.endsWith('SystemInterfaces.cobra')
			_csFileName = _fileName + '.cs'

	get topNameSpace from var
		"""
		Returns the top namespace for this module.
		This is an implicit namespace that is not unified (its unified namespace is the global namespace).
		"""
	
	def bindUse
		base.bindUse
		.topNameSpace.bindUse

	def _bindInt
		base._bindInt
		.topNameSpace.bindInt

	def _bindImp
		base._bindImp
		assert .didBindInt
		.topNameSpace.bindImp

	def writeSharpDef as Dictionary<of int, int> is override
		base.writeSharpDef
		file = File.createText(_csFileName)
		using sw = SharpWriter(file)
			.compiler.addIntermediateFile(_csFileName)
			sw.write('// [_csFileName]\n')
			sw.write('// Generated by Cobra\n')  # TODO: put version number here
			sw.write('// on [DateTime.now]\n')
			# TODO: list op sys
			sw.write('\n')
			.topNameSpace.writeSharpDef(sw)
			d = sw.sharpToCobraLineNum
		return d

	def writeSharpTestInvocation(sw as SharpWriter) is override
		.topNameSpace.writeSharpTestInvocation(sw)
